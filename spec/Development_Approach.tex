\sekshun{Development Approach}
\label{Development_Approach}
\index{development approach}

Before we dive into developing requirements and hacking away at code, a brief description of 
this book's approach to software development, a hybrid of Test-Driven Development and 
Literate Programming, is in order.

\section{Test-Driven Development}
Test-driven development, or TDD, is the notion that developers will improve both the design and
accuracy of their code by writing the test for a particular feature \textit{before writing the 
code that implements the feature according to the specification}. In other words, the TDD process 
begins with writing an automated test for code that does not yet 
exist. After a test is written for a particular feature defined in the specification, the 
programmer then writes the implementing code to get the test to pass. This process is repeated until
all features in the specification are implemented. 

The idea is that by writing tests before code, rather than after, the tests will help guide
the design in small, incremental steps. Over time, this creates a well-factored and robust
codebase that is easier to modify.

\begin{TODO}
Consider adding a story about TDD.
\end{TODO}

\subsection{The TDD Process}
\begin{TODO} The following process is almost ver batim from Rails 4 Test Prescriptions. Need to 
cite the work and tailor to technical computing/Chapel code development.
\end{TODO}
The classic TDD process goes something like this:
\begin{enumerate}
\item Create a test. The test should be short and test for one thing in your code. The test
should run automatically.
\item Make sure the test fails. Verifying the test failure before you write code helps ensure
that the test really does what you expect.
\item Write the simplest code that could possibly make the test pass. Don't worry about good
code yet. Don't look ahead. Sometimes, write just enough code to clear the current error.
\item After the test passes, refactor to improve the code. Clean up duplication. Optimize.
Create new abstractions. Refactoring is a key part of design, so don't skip this. Remmeber to
run the tests again to make sure you haven't changed any behavior.
\end{enumerate}

Repeat the above cycle until your code is complete. This will, in theory, ensure that your code is
always as simple as possible and completely covered by tests. 

\subsection{TDD Aids Design}

\begin{TODO}
Describe in more detail how TDD aids design. Draw from Rails Test Prescriptions, pg 5+.
\end{TODO}

\subsection{Tests as Code Documentation}
A case can be made in some domains (e.g. web development) that automated test suites 
provide an alternate means of documenting code--that
the tests are, in essence, a detailed specification of the code's behavior. This is somewhat true in
technical computing, but full documentation of scientific and engineering software requires 
more than just brief comments and example output. Surely, documentation for a function that computes 
the electron-electron repulsion integral in a quantum chemistry code must have some description
of the type of electronic wavefunction for which the code is valid!

\section{Literate Programming}
Enter stage right...literate programming.  

A typical computer program consists of a text file 
containing program code. Strewn throughout will likely be scant plain text descriptions separated out by 
``comment delimeters'' that document various aspects of the code.
Since the actual code itself is presented in a such a way that supports the syntax, ordering, and structure 
that the programming language (and hence compiler) requires, the code comments will
be relatively disorganized and disjointed if you are reading them for documentation purposes. 
The way a code suite is organized in source is generally much different than the way thorough documentation is 
developed. The plain text nature of the comments also greatly limits their information value.

In literate programming the emphasis is reversed. Instead of writing \textit{a lot of} code that contains 
\textit{some} plain text documentation, 
the literate programmer writes \textit{thorough, well-organized, and content-rich} documentation that contains 
\textit{modular and efficient} code. 
The result is that the commentary is no longer hidden within a program surrounded by 
comment delimiters; instead, it is made the main focus. 
The ``program'' becomes primarily a document directed at humans, with the 
code interspersed within the documentation, separted out by ``code delimiters'' so that it can be extracted 
out and processed into source code by literate programming tools.

\begin{quote}
``The effect of this simple shift of emphasis can be so profound as to change one's whole approach to programming. Under the literate programming paradigm, the central activity of programming becomes that of conveying meaning to other intelligent beings rather than merely convincing the computer to behave in a particular way. It is the difference between performing and exposing a magic trick.'' 
\begin{flushright}
-FunnelWeb Tutorial Manual\cite{funnelweb-what-is-literate-programming}
\end{flushright}
\end{quote}

The following list of requirements can be used to define a ``literate program:''\cite{childs} 

\begin{enumerate}
\item The high-level language code and the associated documentation come from the same 
set of source files.
\item The documentation and high-level language code for a given aspect of the program should be 
adjacent to each other when presented to the reader.
\item The literate program should be subdivided in a logical way.
\item The program should be presented in an order that is logical from the standpoint of documentation
rather than to conform to syntactic constraints of the underlying programming language(s).
\item The documentation should include notes on open issues and future areas for development.
\item Most importantly, the documentation should include a description of the problem and its solution. 
This should include all aids such as mathematics and graphics that enhance communication of the problem 
statement and the understanding of its challenge.
\item Cross references, indices, and different fonts for text, high-level language keywords, 
variable names, and literals should be reasonably automatic and obvious in the source and the documentation.
\item The program is written in small chunks that include the documentation, definitions, and code.
\end{enumerate}

The documentation portion may be any text that aids the understanding of the problem solved by the code 
(\eg description of the algorithm that is implemented).  The documentation is often significantly 
longer than the code itself. Ideally, the problem is described in a way that is agnostic of the language
in which the code is written.  For example, documentation for code that integrates a function $f(x)$ would
have discussion of discontinuities, various integration methods available (\eg trapezoidal, Simpson), 
domain of integration, \etc. 

\section{Hybrid Test-Driven Design and Literate Programming}
The \lstinline{seamless} package aims to enable a hybrid of the TDD and LP approaches for development
of Chapel code.

\begin{TODO}
A brief description of the hybrid approach and how it will be executed. Describe how it meets the intent of
both and enables the benefits of both simultaneously.
\end{TODO}

\begin{TODO}
A note about how I'll try to help the reader understand this as we progress and use the seamless
tools to execute the hybrid TDD-LP approach. Also, a note about theory versus practice for Chapel 
code development.
\end{TODO}
