\sekshun{Development Approach}
\label{Development_Approach}
\index{development approach}

Before we dive into developing requirements and code, a brief description of this book's approach, a hybrid of 
Test-Driven Development and Literate Programming (TDD-LP), is in order.

\section{Test-Driven Development}
Test-driven development, or TDD, is the notion that developers will improve both the design and
accuracy of their code by writing the test for a particular feature \textit{before writing the 
code that implements the feature according to the specification}. In other words, the TDD process 
begins with writing an automated test for code that does not yet 
exist. After a test is written for a particular feature defined in the specification, the 
programmer then writes the implementing code to get the test to pass. This process is repeated until
all features in the specification are implemented. 

The idea is that by writing tests before code, rather than after, the tests will help guide
the design in small, incremental steps. Over time, this creates a well-factored and robust
codebase that is easier to modify.

\begin{TODO}
Consider adding a story about TDD.
\end{TODO}

\subsection{The TDD Process}
\begin{TODO} The following process is almost ver batim from Rails 4 Test Prescriptions. Need to 
cite the work and tailor to technical computing/Chapel code development.
\end{TODO}
The classic TDD process goes something like this:
\begin{enumerate}
\item Create a test. The test should be short and test for one thing in your code. The test
should run automatically.
\item Make sure the test fails. Verifying the test failure before you write code helps ensure
that the test really does what you expect.
\item Write the simplest code that could possibly make the test pass. Don't worry about good
code yet. Don't look ahead. Sometimes, write just enough code to clear the current error.
\item After the test passes, refactor to improve the code. Clean up duplication. Optimize.
Create new abstractions. Refactoring is a key part of design, so don't skip this. Remmeber to
run the tests again to make sure you haven't changed any behavior.
\end{enumerate}

Repeat the above cycle until your code is complete. This will, in theory, ensure that your code is
always as simple as possible and completely covered by tests. 

\subsection{TDD Aids Design}

\begin{TODO}
Describe in more detail how TDD aids design. Draw from Rails Test Prescriptions, pg 5+.
\end{TODO}

\subsection{Tests as Code Documentation}
A case can be made in some domains (e.g. web development) that automated test suites 
provide an alternate means of documenting code--that
the tests are, in essence, a detailed specification of the code's behavior. This is somewhat true in
technical computing, but full documentation of scientific and engineering software requires 
more than just brief comments and example output. Surely, documentation for a function that computes 
the electron-electron repulsion integral in a quantum chemistry code must have some description
of the type of electronic wavefunction for which the code is valid!

\section{Literate Programming}
\begin{TODO}
Add description of LP and its benefits. 
\end{TODO}

Childs\cite{childs} uses the following list of requirements to imply a definition of a ``literate program'': 

\begin{enumerate}
\item The high-level language code and the system documentation of the program come from the same 
set of source files.
\item The documentation and high-level language code are complementary and should address the same 
elements of the algorithms being written.
\item The literate program should have logical subdivisions. Knuth called these modules or sections.
\item The system should be presented in an order based upon logical considerations rather than 
syntactic constraints.
\item The documentation should include an examination of alternative solutions and should suggest 
future maintenance problems and extensions.
\item The documentation should include a description of the problem and its solution. This should 
include all aids such as mathematics and graphics that enhance communication of the problem statement 
and the understanding of its challenge.
\item Cross references, indices, and different fonts for text, high-level language keywords, 
variable names, and literals should be reasonably automatic and obvious in the source and the documentation.
\item The approach encourages writing programs in small chunks that include the documentation, 
definitions, and code.
\end{enumerate}

The documentation portion may be any text that aids the understanding of the problem solved by the code 
(\eg a description of the algorithm that is implemented).  The documentation is often significantly 
longer than the code itself. Ideally, the problem is described in a way that is agnostic of the language
in which the code is written.  For example, documentation for code that integrates a function $f(x)$ would
have discussion of discontinuities, various integration methods available (\eg trapezoidal, Simpson), 
domain of integration, etc. 

\section{Hybrid Test-Driven Design and Literate Programming}
The \lstinline{seamless} package aims to enable a hybrid of the TDD and LP approaches for development
of Chapel code.

\begin{TODO}
A brief description of the hybrid approach and how it will be executed. Describe how it meets the intent of
both and enables the benefits of both simultaneously.
\end{TODO}

\begin{TODO}
A note about how I'll try to help the reader understand this as we progress and use the seamless
tools to execute the hybrid TDD-LP approach. Also, a note about theory versus practice for Chapel 
code development.
\end{TODO}
